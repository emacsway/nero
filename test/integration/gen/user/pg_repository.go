// Code generated by nero, DO NOT EDIT.
package user

import (
	"context"
	"database/sql"
	sq "github.com/Masterminds/squirrel"
	_ "github.com/lib/pq"
	errors "github.com/pkg/errors"
	nero "github.com/sf9v/nero"
	predicate "github.com/sf9v/nero/predicate"
	user "github.com/sf9v/nero/test/integration/user"
)

type PGRepository struct {
	db *sql.DB
}

var _ = Repository(&PGRepository{})

func NewPGRepository(db *sql.DB) *PGRepository {
	return &PGRepository{
		db: db,
	}
}

func (s *PGRepository) Tx(ctx context.Context) (nero.Tx, error) {
	return s.db.BeginTx(ctx, &sql.TxOptions{})
}

func (s *PGRepository) Create(ctx context.Context, c *Creator) (int64, error) {
	tx, err := s.Tx(ctx)
	if err != nil {
		return 0, err
	}
	defer func() {
		if err != nil && tx != nil {
			if rollbackErr := tx.Rollback(); rollbackErr != nil {
				err = errors.Wrapf(err, "rollback error: %v", rollbackErr)
			}
			return
		}

		if err = tx.Commit(); err != nil {
			err = errors.Wrap(err, "commit error")
		}
	}()

	id, err := s.CreateTx(ctx, tx, c)
	if err != nil {
		return 0, err
	}

	return id, nil
}

func (s *PGRepository) Query(ctx context.Context, q *Queryer) ([]*user.User, error) {
	tx, err := s.Tx(ctx)
	if err != nil {
		return nil, err
	}
	defer func() {
		if err != nil && tx != nil {
			if rollbackErr := tx.Rollback(); rollbackErr != nil {
				err = errors.Wrapf(err, "rollback error: %v", rollbackErr)
			}
			return
		}

		if err = tx.Commit(); err != nil {
			err = errors.Wrap(err, "commit error")
		}
	}()

	list, err := s.QueryTx(ctx, tx, q)
	if err != nil {
		return nil, err
	}

	return list, nil
}

func (s *PGRepository) Update(ctx context.Context, u *Updater) (int64, error) {
	tx, err := s.Tx(ctx)
	if err != nil {
		return 0, err
	}
	defer func() {
		if err != nil && tx != nil {
			if rollbackErr := tx.Rollback(); rollbackErr != nil {
				err = errors.Wrapf(err, "rollback error: %v", rollbackErr)
			}
			return
		}

		if err = tx.Commit(); err != nil {
			err = errors.Wrap(err, "commit error")
		}
	}()

	rowsAffected, err := s.UpdateTx(ctx, tx, u)
	if err != nil {
		return 0, err
	}

	return rowsAffected, nil
}

func (s *PGRepository) Delete(ctx context.Context, d *Deleter) (int64, error) {
	tx, err := s.Tx(ctx)
	if err != nil {
		return 0, err
	}
	defer func() {
		if err != nil && tx != nil {
			if rollbackErr := tx.Rollback(); rollbackErr != nil {
				err = errors.Wrapf(err, "rollback error: %v", rollbackErr)
			}
			return
		}

		if err = tx.Commit(); err != nil {
			err = errors.Wrap(err, "commit error")
		}
	}()

	rowsAffected, err := s.DeleteTx(ctx, tx, d)
	if err != nil {
		return 0, err
	}

	return rowsAffected, nil
}

func (s *PGRepository) CreateTx(ctx context.Context, tx nero.Tx, c *Creator) (int64, error) {
	txx, ok := tx.(*sql.Tx)
	if !ok {
		return 0, errors.New("expecting tx to be *sql.Tx")
	}

	qb := sq.StatementBuilder.
		PlaceholderFormat(sq.Dollar).
		Insert(c.collection).
		Columns(c.columns...).
		Values(c.email, c.name, c.updatedAt).
		Suffix("RETURNING \"id\"").
		RunWith(txx)
	var id int64
	err := qb.QueryRowContext(ctx).Scan(&id)
	if err != nil {
		return 0, err
	}

	return id, nil
}

func (s *PGRepository) QueryTx(ctx context.Context, tx nero.Tx, q *Queryer) ([]*user.User, error) {
	txx, ok := tx.(*sql.Tx)
	if !ok {
		return nil, errors.New("expecting tx to be *sql.Tx")
	}

	pb := &predicate.Builder{}
	for _, pf := range q.pfs {
		pf(pb)
	}

	psql := sq.StatementBuilder.PlaceholderFormat(sq.Dollar)
	sb := psql.Select(q.columns...).From(q.collection)
	for _, p := range pb.Predicates() {
		switch p.Op {
		case predicate.Eq:
			sb = sb.Where(sq.Eq{
				p.Field: p.Val,
			})
		case predicate.NotEq:
			sb = sb.Where(sq.NotEq{
				p.Field: p.Val,
			})
		case predicate.Gt:
			sb = sb.Where(sq.Gt{
				p.Field: p.Val,
			})
		case predicate.GtOrEq:
			sb = sb.Where(sq.GtOrEq{
				p.Field: p.Val,
			})
		case predicate.Lt:
			sb = sb.Where(sq.Lt{
				p.Field: p.Val,
			})
		case predicate.LtOrEq:
			sb = sb.Where(sq.LtOrEq{
				p.Field: p.Val,
			})
		}
	}

	if q.limit > 0 {
		sb = sb.Limit(q.limit)
	}

	if q.offset > 0 {
		sb = sb.Offset(q.offset)
	}

	sql, args, err := sb.ToSql()
	if err != nil {
		return nil, err
	}

	stmnt, err := txx.PrepareContext(ctx, sql)
	if err != nil {
		return nil, err
	}

	rows, err := stmnt.QueryContext(ctx, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	list := []*user.User{}
	for rows.Next() {
		var item user.User
		err = rows.Scan(
			&item.ID,
			&item.Email,
			&item.Name,
			&item.UpdatedAt,
			&item.CreatedAt,
		)
		if err != nil {
			return nil, err
		}

		list = append(list, &item)
	}

	return list, nil
}

func (s *PGRepository) UpdateTx(ctx context.Context, tx nero.Tx, u *Updater) (int64, error) {
	txx, ok := tx.(*sql.Tx)
	if !ok {
		return 0, errors.New("expecting tx to be *sql.Tx")
	}

	pb := &predicate.Builder{}
	for _, pf := range u.pfs {
		pf(pb)
	}

	psql := sq.StatementBuilder.PlaceholderFormat(sq.Dollar)
	sb := psql.Update(u.collection).Set("email", u.email).Set("name", u.name).Set("updated_at", u.updatedAt)
	for _, p := range pb.Predicates() {
		switch p.Op {
		case predicate.Eq:
			sb = sb.Where(sq.Eq{
				p.Field: p.Val,
			})
		case predicate.NotEq:
			sb = sb.Where(sq.NotEq{
				p.Field: p.Val,
			})
		case predicate.Gt:
			sb = sb.Where(sq.Gt{
				p.Field: p.Val,
			})
		case predicate.GtOrEq:
			sb = sb.Where(sq.GtOrEq{
				p.Field: p.Val,
			})
		case predicate.Lt:
			sb = sb.Where(sq.Lt{
				p.Field: p.Val,
			})
		case predicate.LtOrEq:
			sb = sb.Where(sq.LtOrEq{
				p.Field: p.Val,
			})
		}
	}

	sql, args, err := sb.ToSql()
	if err != nil {
		return 0, err
	}

	stmnt, err := txx.PrepareContext(ctx, sql)
	if err != nil {
		return 0, err
	}

	res, err := stmnt.ExecContext(ctx, args...)
	if err != nil {
		return 0, err
	}

	rowsAffected, err := res.RowsAffected()
	if err != nil {
		return 0, err
	}

	return rowsAffected, nil
}

func (s *PGRepository) DeleteTx(ctx context.Context, tx nero.Tx, d *Deleter) (int64, error) {
	txx, ok := tx.(*sql.Tx)
	if !ok {
		return 0, errors.New("expecting tx to be *sql.Tx")
	}

	pb := &predicate.Builder{}
	for _, pf := range d.pfs {
		pf(pb)
	}

	psql := sq.StatementBuilder.PlaceholderFormat(sq.Dollar)
	sb := psql.Delete(d.collection)
	for _, p := range pb.Predicates() {
		switch p.Op {
		case predicate.Eq:
			sb = sb.Where(sq.Eq{
				p.Field: p.Val,
			})
		case predicate.NotEq:
			sb = sb.Where(sq.NotEq{
				p.Field: p.Val,
			})
		case predicate.Gt:
			sb = sb.Where(sq.Gt{
				p.Field: p.Val,
			})
		case predicate.GtOrEq:
			sb = sb.Where(sq.GtOrEq{
				p.Field: p.Val,
			})
		case predicate.Lt:
			sb = sb.Where(sq.Lt{
				p.Field: p.Val,
			})
		case predicate.LtOrEq:
			sb = sb.Where(sq.LtOrEq{
				p.Field: p.Val,
			})
		}
	}

	sql, args, err := sb.ToSql()
	if err != nil {
		return 0, err
	}

	stmnt, err := txx.PrepareContext(ctx, sql)
	if err != nil {
		return 0, err
	}

	res, err := stmnt.ExecContext(ctx, args...)
	if err != nil {
		return 0, err
	}

	rowsAffected, err := res.RowsAffected()
	if err != nil {
		return 0, err
	}

	return rowsAffected, nil
}
