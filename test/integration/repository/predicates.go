// Code generated by nero, DO NOT EDIT.
package repository

import (
	ksuid "github.com/segmentio/ksuid"
	comparison "github.com/sf9v/nero/comparison"
	user "github.com/sf9v/nero/test/integration/user"
	"time"
)

// PredFunc is the predicate function type
type PredFunc func(*comparison.Predicates)

// IDEq returns a/an equal predicate on id
func IDEq(id string) PredFunc {
	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "id",
			Op:  comparison.Eq,
			Val: id,
		})
	}
}

// IDNotEq returns a/an not equal predicate on id
func IDNotEq(id string) PredFunc {
	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "id",
			Op:  comparison.NotEq,
			Val: id,
		})
	}
}

// IDGt returns a/an greater than predicate on id
func IDGt(id string) PredFunc {
	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "id",
			Op:  comparison.Gt,
			Val: id,
		})
	}
}

// IDGtOrEq returns a/an greater than or equal predicate on id
func IDGtOrEq(id string) PredFunc {
	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "id",
			Op:  comparison.GtOrEq,
			Val: id,
		})
	}
}

// IDLt returns a/an less than predicate on id
func IDLt(id string) PredFunc {
	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "id",
			Op:  comparison.Lt,
			Val: id,
		})
	}
}

// IDLtOrEq returns a/an less than or equal predicate on id
func IDLtOrEq(id string) PredFunc {
	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "id",
			Op:  comparison.LtOrEq,
			Val: id,
		})
	}
}

func IDIn(ids ...string) PredFunc {
	vals := []interface{}{}
	for _, v := range ids {
		vals = append(vals, v)
	}
	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "id",
			Op:  comparison.In,
			Val: vals,
		})
	}
}

func IDNotIn(ids ...string) PredFunc {
	vals := []interface{}{}
	for _, v := range ids {
		vals = append(vals, v)
	}
	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "id",
			Op:  comparison.NotIn,
			Val: vals,
		})
	}
}

// UIDEq returns a/an equal predicate on uid
func UIDEq(uid ksuid.KSUID) PredFunc {
	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "uid",
			Op:  comparison.Eq,
			Val: uid,
		})
	}
}

// UIDNotEq returns a/an not equal predicate on uid
func UIDNotEq(uid ksuid.KSUID) PredFunc {
	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "uid",
			Op:  comparison.NotEq,
			Val: uid,
		})
	}
}

// UIDGt returns a/an greater than predicate on uid
func UIDGt(uid ksuid.KSUID) PredFunc {
	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "uid",
			Op:  comparison.Gt,
			Val: uid,
		})
	}
}

// UIDGtOrEq returns a/an greater than or equal predicate on uid
func UIDGtOrEq(uid ksuid.KSUID) PredFunc {
	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "uid",
			Op:  comparison.GtOrEq,
			Val: uid,
		})
	}
}

// UIDLt returns a/an less than predicate on uid
func UIDLt(uid ksuid.KSUID) PredFunc {
	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "uid",
			Op:  comparison.Lt,
			Val: uid,
		})
	}
}

// UIDLtOrEq returns a/an less than or equal predicate on uid
func UIDLtOrEq(uid ksuid.KSUID) PredFunc {
	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "uid",
			Op:  comparison.LtOrEq,
			Val: uid,
		})
	}
}

func UIDIn(uids ...ksuid.KSUID) PredFunc {
	vals := []interface{}{}
	for _, v := range uids {
		vals = append(vals, v)
	}
	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "uid",
			Op:  comparison.In,
			Val: vals,
		})
	}
}

func UIDNotIn(uids ...ksuid.KSUID) PredFunc {
	vals := []interface{}{}
	for _, v := range uids {
		vals = append(vals, v)
	}
	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "uid",
			Op:  comparison.NotIn,
			Val: vals,
		})
	}
}

// EmailEq returns a/an equal predicate on email
func EmailEq(email string) PredFunc {
	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "email",
			Op:  comparison.Eq,
			Val: email,
		})
	}
}

// EmailNotEq returns a/an not equal predicate on email
func EmailNotEq(email string) PredFunc {
	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "email",
			Op:  comparison.NotEq,
			Val: email,
		})
	}
}

// EmailGt returns a/an greater than predicate on email
func EmailGt(email string) PredFunc {
	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "email",
			Op:  comparison.Gt,
			Val: email,
		})
	}
}

// EmailGtOrEq returns a/an greater than or equal predicate on email
func EmailGtOrEq(email string) PredFunc {
	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "email",
			Op:  comparison.GtOrEq,
			Val: email,
		})
	}
}

// EmailLt returns a/an less than predicate on email
func EmailLt(email string) PredFunc {
	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "email",
			Op:  comparison.Lt,
			Val: email,
		})
	}
}

// EmailLtOrEq returns a/an less than or equal predicate on email
func EmailLtOrEq(email string) PredFunc {
	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "email",
			Op:  comparison.LtOrEq,
			Val: email,
		})
	}
}

func EmailIn(emails ...string) PredFunc {
	vals := []interface{}{}
	for _, v := range emails {
		vals = append(vals, v)
	}
	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "email",
			Op:  comparison.In,
			Val: vals,
		})
	}
}

func EmailNotIn(emails ...string) PredFunc {
	vals := []interface{}{}
	for _, v := range emails {
		vals = append(vals, v)
	}
	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "email",
			Op:  comparison.NotIn,
			Val: vals,
		})
	}
}

// NameEq returns a/an equal predicate on name
func NameEq(name string) PredFunc {
	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "name",
			Op:  comparison.Eq,
			Val: name,
		})
	}
}

// NameNotEq returns a/an not equal predicate on name
func NameNotEq(name string) PredFunc {
	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "name",
			Op:  comparison.NotEq,
			Val: name,
		})
	}
}

// NameGt returns a/an greater than predicate on name
func NameGt(name string) PredFunc {
	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "name",
			Op:  comparison.Gt,
			Val: name,
		})
	}
}

// NameGtOrEq returns a/an greater than or equal predicate on name
func NameGtOrEq(name string) PredFunc {
	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "name",
			Op:  comparison.GtOrEq,
			Val: name,
		})
	}
}

// NameLt returns a/an less than predicate on name
func NameLt(name string) PredFunc {
	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "name",
			Op:  comparison.Lt,
			Val: name,
		})
	}
}

// NameLtOrEq returns a/an less than or equal predicate on name
func NameLtOrEq(name string) PredFunc {
	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "name",
			Op:  comparison.LtOrEq,
			Val: name,
		})
	}
}

func NameIn(names ...string) PredFunc {
	vals := []interface{}{}
	for _, v := range names {
		vals = append(vals, v)
	}
	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "name",
			Op:  comparison.In,
			Val: vals,
		})
	}
}

func NameNotIn(names ...string) PredFunc {
	vals := []interface{}{}
	for _, v := range names {
		vals = append(vals, v)
	}
	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "name",
			Op:  comparison.NotIn,
			Val: vals,
		})
	}
}

// AgeEq returns a/an equal predicate on age
func AgeEq(age int) PredFunc {
	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "age",
			Op:  comparison.Eq,
			Val: age,
		})
	}
}

// AgeNotEq returns a/an not equal predicate on age
func AgeNotEq(age int) PredFunc {
	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "age",
			Op:  comparison.NotEq,
			Val: age,
		})
	}
}

// AgeGt returns a/an greater than predicate on age
func AgeGt(age int) PredFunc {
	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "age",
			Op:  comparison.Gt,
			Val: age,
		})
	}
}

// AgeGtOrEq returns a/an greater than or equal predicate on age
func AgeGtOrEq(age int) PredFunc {
	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "age",
			Op:  comparison.GtOrEq,
			Val: age,
		})
	}
}

// AgeLt returns a/an less than predicate on age
func AgeLt(age int) PredFunc {
	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "age",
			Op:  comparison.Lt,
			Val: age,
		})
	}
}

// AgeLtOrEq returns a/an less than or equal predicate on age
func AgeLtOrEq(age int) PredFunc {
	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "age",
			Op:  comparison.LtOrEq,
			Val: age,
		})
	}
}

func AgeIn(ages ...int) PredFunc {
	vals := []interface{}{}
	for _, v := range ages {
		vals = append(vals, v)
	}
	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "age",
			Op:  comparison.In,
			Val: vals,
		})
	}
}

func AgeNotIn(ages ...int) PredFunc {
	vals := []interface{}{}
	for _, v := range ages {
		vals = append(vals, v)
	}
	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "age",
			Op:  comparison.NotIn,
			Val: vals,
		})
	}
}

// GroupEq returns a/an equal predicate on group
func GroupEq(group user.Group) PredFunc {
	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "group",
			Op:  comparison.Eq,
			Val: group,
		})
	}
}

// GroupNotEq returns a/an not equal predicate on group
func GroupNotEq(group user.Group) PredFunc {
	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "group",
			Op:  comparison.NotEq,
			Val: group,
		})
	}
}

// GroupGt returns a/an greater than predicate on group
func GroupGt(group user.Group) PredFunc {
	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "group",
			Op:  comparison.Gt,
			Val: group,
		})
	}
}

// GroupGtOrEq returns a/an greater than or equal predicate on group
func GroupGtOrEq(group user.Group) PredFunc {
	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "group",
			Op:  comparison.GtOrEq,
			Val: group,
		})
	}
}

// GroupLt returns a/an less than predicate on group
func GroupLt(group user.Group) PredFunc {
	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "group",
			Op:  comparison.Lt,
			Val: group,
		})
	}
}

// GroupLtOrEq returns a/an less than or equal predicate on group
func GroupLtOrEq(group user.Group) PredFunc {
	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "group",
			Op:  comparison.LtOrEq,
			Val: group,
		})
	}
}

func GroupIn(groups ...user.Group) PredFunc {
	vals := []interface{}{}
	for _, v := range groups {
		vals = append(vals, v)
	}
	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "group",
			Op:  comparison.In,
			Val: vals,
		})
	}
}

func GroupNotIn(groups ...user.Group) PredFunc {
	vals := []interface{}{}
	for _, v := range groups {
		vals = append(vals, v)
	}
	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "group",
			Op:  comparison.NotIn,
			Val: vals,
		})
	}
}

// UpdatedAtEq returns a/an equal predicate on updatedAt
func UpdatedAtEq(updatedAt *time.Time) PredFunc {
	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "updated_at",
			Op:  comparison.Eq,
			Val: updatedAt,
		})
	}
}

// UpdatedAtNotEq returns a/an not equal predicate on updatedAt
func UpdatedAtNotEq(updatedAt *time.Time) PredFunc {
	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "updated_at",
			Op:  comparison.NotEq,
			Val: updatedAt,
		})
	}
}

// UpdatedAtGt returns a/an greater than predicate on updatedAt
func UpdatedAtGt(updatedAt *time.Time) PredFunc {
	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "updated_at",
			Op:  comparison.Gt,
			Val: updatedAt,
		})
	}
}

// UpdatedAtGtOrEq returns a/an greater than or equal predicate on updatedAt
func UpdatedAtGtOrEq(updatedAt *time.Time) PredFunc {
	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "updated_at",
			Op:  comparison.GtOrEq,
			Val: updatedAt,
		})
	}
}

// UpdatedAtLt returns a/an less than predicate on updatedAt
func UpdatedAtLt(updatedAt *time.Time) PredFunc {
	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "updated_at",
			Op:  comparison.Lt,
			Val: updatedAt,
		})
	}
}

// UpdatedAtLtOrEq returns a/an less than or equal predicate on updatedAt
func UpdatedAtLtOrEq(updatedAt *time.Time) PredFunc {
	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "updated_at",
			Op:  comparison.LtOrEq,
			Val: updatedAt,
		})
	}
}

func UpdatedAtIsNull() PredFunc {
	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "updated_at",
			Op:  comparison.IsNull,
		})
	}
}

func UpdatedAtIsNotNull() PredFunc {
	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "updated_at",
			Op:  comparison.IsNotNull,
		})
	}
}

func UpdatedAtIn(updatedAts ...*time.Time) PredFunc {
	vals := []interface{}{}
	for _, v := range updatedAts {
		vals = append(vals, v)
	}
	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "updated_at",
			Op:  comparison.In,
			Val: vals,
		})
	}
}

func UpdatedAtNotIn(updatedAts ...*time.Time) PredFunc {
	vals := []interface{}{}
	for _, v := range updatedAts {
		vals = append(vals, v)
	}
	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "updated_at",
			Op:  comparison.NotIn,
			Val: vals,
		})
	}
}

// CreatedAtEq returns a/an equal predicate on createdAt
func CreatedAtEq(createdAt *time.Time) PredFunc {
	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "created_at",
			Op:  comparison.Eq,
			Val: createdAt,
		})
	}
}

// CreatedAtNotEq returns a/an not equal predicate on createdAt
func CreatedAtNotEq(createdAt *time.Time) PredFunc {
	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "created_at",
			Op:  comparison.NotEq,
			Val: createdAt,
		})
	}
}

// CreatedAtGt returns a/an greater than predicate on createdAt
func CreatedAtGt(createdAt *time.Time) PredFunc {
	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "created_at",
			Op:  comparison.Gt,
			Val: createdAt,
		})
	}
}

// CreatedAtGtOrEq returns a/an greater than or equal predicate on createdAt
func CreatedAtGtOrEq(createdAt *time.Time) PredFunc {
	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "created_at",
			Op:  comparison.GtOrEq,
			Val: createdAt,
		})
	}
}

// CreatedAtLt returns a/an less than predicate on createdAt
func CreatedAtLt(createdAt *time.Time) PredFunc {
	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "created_at",
			Op:  comparison.Lt,
			Val: createdAt,
		})
	}
}

// CreatedAtLtOrEq returns a/an less than or equal predicate on createdAt
func CreatedAtLtOrEq(createdAt *time.Time) PredFunc {
	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "created_at",
			Op:  comparison.LtOrEq,
			Val: createdAt,
		})
	}
}

func CreatedAtIn(createdAts ...*time.Time) PredFunc {
	vals := []interface{}{}
	for _, v := range createdAts {
		vals = append(vals, v)
	}
	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "created_at",
			Op:  comparison.In,
			Val: vals,
		})
	}
}

func CreatedAtNotIn(createdAts ...*time.Time) PredFunc {
	vals := []interface{}{}
	for _, v := range createdAts {
		vals = append(vals, v)
	}
	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "created_at",
			Op:  comparison.NotIn,
			Val: vals,
		})
	}
}
