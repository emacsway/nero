// Code generated by nero, DO NOT EDIT.
package repository

import (
	"time"

	"github.com/segmentio/ksuid"
	"github.com/sf9v/nero/comparison"
	"github.com/sf9v/nero/test/integration/user"
)

type PredFunc func(*comparison.Predicates)

func IDEq(id string) PredFunc {
	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "id",
			Op:  comparison.Eq,
			Arg: id,
		})
	}
}

func IDNotEq(id string) PredFunc {
	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "id",
			Op:  comparison.NotEq,
			Arg: id,
		})
	}
}

func IDGt(id string) PredFunc {
	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "id",
			Op:  comparison.Gt,
			Arg: id,
		})
	}
}

func IDGtOrEq(id string) PredFunc {
	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "id",
			Op:  comparison.GtOrEq,
			Arg: id,
		})
	}
}

func IDLt(id string) PredFunc {
	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "id",
			Op:  comparison.Lt,
			Arg: id,
		})
	}
}

func IDLtOrEq(id string) PredFunc {
	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "id",
			Op:  comparison.LtOrEq,
			Arg: id,
		})
	}
}

func IDIsNull() PredFunc {
	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "id",
			Op:  comparison.IsNull,
		})
	}
}

func IDIsNotNull() PredFunc {
	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "id",
			Op:  comparison.IsNotNull,
		})
	}
}

func IDIn(ids ...string) PredFunc {
	args := []interface{}{}
	for _, v := range ids {
		args = append(args, v)
	}

	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "id",
			Op:  comparison.In,
			Arg: args,
		})
	}
}

func IDNotIn(ids ...string) PredFunc {
	args := []interface{}{}
	for _, v := range ids {
		args = append(args, v)
	}

	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "id",
			Op:  comparison.NotIn,
			Arg: args,
		})
	}
}

func UIDEq(uid ksuid.KSUID) PredFunc {
	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "uid",
			Op:  comparison.Eq,
			Arg: uid,
		})
	}
}

func UIDNotEq(uid ksuid.KSUID) PredFunc {
	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "uid",
			Op:  comparison.NotEq,
			Arg: uid,
		})
	}
}

func UIDGt(uid ksuid.KSUID) PredFunc {
	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "uid",
			Op:  comparison.Gt,
			Arg: uid,
		})
	}
}

func UIDGtOrEq(uid ksuid.KSUID) PredFunc {
	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "uid",
			Op:  comparison.GtOrEq,
			Arg: uid,
		})
	}
}

func UIDLt(uid ksuid.KSUID) PredFunc {
	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "uid",
			Op:  comparison.Lt,
			Arg: uid,
		})
	}
}

func UIDLtOrEq(uid ksuid.KSUID) PredFunc {
	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "uid",
			Op:  comparison.LtOrEq,
			Arg: uid,
		})
	}
}

func UIDIsNull() PredFunc {
	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "uid",
			Op:  comparison.IsNull,
		})
	}
}

func UIDIsNotNull() PredFunc {
	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "uid",
			Op:  comparison.IsNotNull,
		})
	}
}

func UIDIn(uids ...ksuid.KSUID) PredFunc {
	args := []interface{}{}
	for _, v := range uids {
		args = append(args, v)
	}

	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "uid",
			Op:  comparison.In,
			Arg: args,
		})
	}
}

func UIDNotIn(uids ...ksuid.KSUID) PredFunc {
	args := []interface{}{}
	for _, v := range uids {
		args = append(args, v)
	}

	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "uid",
			Op:  comparison.NotIn,
			Arg: args,
		})
	}
}

func EmailEq(email string) PredFunc {
	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "email",
			Op:  comparison.Eq,
			Arg: email,
		})
	}
}

func EmailNotEq(email string) PredFunc {
	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "email",
			Op:  comparison.NotEq,
			Arg: email,
		})
	}
}

func EmailGt(email string) PredFunc {
	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "email",
			Op:  comparison.Gt,
			Arg: email,
		})
	}
}

func EmailGtOrEq(email string) PredFunc {
	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "email",
			Op:  comparison.GtOrEq,
			Arg: email,
		})
	}
}

func EmailLt(email string) PredFunc {
	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "email",
			Op:  comparison.Lt,
			Arg: email,
		})
	}
}

func EmailLtOrEq(email string) PredFunc {
	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "email",
			Op:  comparison.LtOrEq,
			Arg: email,
		})
	}
}

func EmailIsNull() PredFunc {
	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "email",
			Op:  comparison.IsNull,
		})
	}
}

func EmailIsNotNull() PredFunc {
	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "email",
			Op:  comparison.IsNotNull,
		})
	}
}

func EmailIn(emails ...string) PredFunc {
	args := []interface{}{}
	for _, v := range emails {
		args = append(args, v)
	}

	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "email",
			Op:  comparison.In,
			Arg: args,
		})
	}
}

func EmailNotIn(emails ...string) PredFunc {
	args := []interface{}{}
	for _, v := range emails {
		args = append(args, v)
	}

	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "email",
			Op:  comparison.NotIn,
			Arg: args,
		})
	}
}

func NameEq(name string) PredFunc {
	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "name",
			Op:  comparison.Eq,
			Arg: name,
		})
	}
}

func NameNotEq(name string) PredFunc {
	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "name",
			Op:  comparison.NotEq,
			Arg: name,
		})
	}
}

func NameGt(name string) PredFunc {
	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "name",
			Op:  comparison.Gt,
			Arg: name,
		})
	}
}

func NameGtOrEq(name string) PredFunc {
	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "name",
			Op:  comparison.GtOrEq,
			Arg: name,
		})
	}
}

func NameLt(name string) PredFunc {
	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "name",
			Op:  comparison.Lt,
			Arg: name,
		})
	}
}

func NameLtOrEq(name string) PredFunc {
	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "name",
			Op:  comparison.LtOrEq,
			Arg: name,
		})
	}
}

func NameIsNull() PredFunc {
	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "name",
			Op:  comparison.IsNull,
		})
	}
}

func NameIsNotNull() PredFunc {
	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "name",
			Op:  comparison.IsNotNull,
		})
	}
}

func NameIn(names ...string) PredFunc {
	args := []interface{}{}
	for _, v := range names {
		args = append(args, v)
	}

	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "name",
			Op:  comparison.In,
			Arg: args,
		})
	}
}

func NameNotIn(names ...string) PredFunc {
	args := []interface{}{}
	for _, v := range names {
		args = append(args, v)
	}

	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "name",
			Op:  comparison.NotIn,
			Arg: args,
		})
	}
}

func AgeEq(age int) PredFunc {
	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "age",
			Op:  comparison.Eq,
			Arg: age,
		})
	}
}

func AgeNotEq(age int) PredFunc {
	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "age",
			Op:  comparison.NotEq,
			Arg: age,
		})
	}
}

func AgeGt(age int) PredFunc {
	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "age",
			Op:  comparison.Gt,
			Arg: age,
		})
	}
}

func AgeGtOrEq(age int) PredFunc {
	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "age",
			Op:  comparison.GtOrEq,
			Arg: age,
		})
	}
}

func AgeLt(age int) PredFunc {
	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "age",
			Op:  comparison.Lt,
			Arg: age,
		})
	}
}

func AgeLtOrEq(age int) PredFunc {
	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "age",
			Op:  comparison.LtOrEq,
			Arg: age,
		})
	}
}

func AgeIsNull() PredFunc {
	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "age",
			Op:  comparison.IsNull,
		})
	}
}

func AgeIsNotNull() PredFunc {
	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "age",
			Op:  comparison.IsNotNull,
		})
	}
}

func AgeIn(ages ...int) PredFunc {
	args := []interface{}{}
	for _, v := range ages {
		args = append(args, v)
	}

	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "age",
			Op:  comparison.In,
			Arg: args,
		})
	}
}

func AgeNotIn(ages ...int) PredFunc {
	args := []interface{}{}
	for _, v := range ages {
		args = append(args, v)
	}

	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "age",
			Op:  comparison.NotIn,
			Arg: args,
		})
	}
}

func GroupEq(group user.Group) PredFunc {
	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "group",
			Op:  comparison.Eq,
			Arg: group,
		})
	}
}

func GroupNotEq(group user.Group) PredFunc {
	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "group",
			Op:  comparison.NotEq,
			Arg: group,
		})
	}
}

func GroupGt(group user.Group) PredFunc {
	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "group",
			Op:  comparison.Gt,
			Arg: group,
		})
	}
}

func GroupGtOrEq(group user.Group) PredFunc {
	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "group",
			Op:  comparison.GtOrEq,
			Arg: group,
		})
	}
}

func GroupLt(group user.Group) PredFunc {
	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "group",
			Op:  comparison.Lt,
			Arg: group,
		})
	}
}

func GroupLtOrEq(group user.Group) PredFunc {
	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "group",
			Op:  comparison.LtOrEq,
			Arg: group,
		})
	}
}

func GroupIsNull() PredFunc {
	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "group",
			Op:  comparison.IsNull,
		})
	}
}

func GroupIsNotNull() PredFunc {
	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "group",
			Op:  comparison.IsNotNull,
		})
	}
}

func GroupIn(groups ...user.Group) PredFunc {
	args := []interface{}{}
	for _, v := range groups {
		args = append(args, v)
	}

	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "group",
			Op:  comparison.In,
			Arg: args,
		})
	}
}

func GroupNotIn(groups ...user.Group) PredFunc {
	args := []interface{}{}
	for _, v := range groups {
		args = append(args, v)
	}

	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "group",
			Op:  comparison.NotIn,
			Arg: args,
		})
	}
}

func UpdatedAtEq(updatedAt *time.Time) PredFunc {
	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "updated_at",
			Op:  comparison.Eq,
			Arg: updatedAt,
		})
	}
}

func UpdatedAtNotEq(updatedAt *time.Time) PredFunc {
	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "updated_at",
			Op:  comparison.NotEq,
			Arg: updatedAt,
		})
	}
}

func UpdatedAtGt(updatedAt *time.Time) PredFunc {
	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "updated_at",
			Op:  comparison.Gt,
			Arg: updatedAt,
		})
	}
}

func UpdatedAtGtOrEq(updatedAt *time.Time) PredFunc {
	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "updated_at",
			Op:  comparison.GtOrEq,
			Arg: updatedAt,
		})
	}
}

func UpdatedAtLt(updatedAt *time.Time) PredFunc {
	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "updated_at",
			Op:  comparison.Lt,
			Arg: updatedAt,
		})
	}
}

func UpdatedAtLtOrEq(updatedAt *time.Time) PredFunc {
	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "updated_at",
			Op:  comparison.LtOrEq,
			Arg: updatedAt,
		})
	}
}

func UpdatedAtIsNull() PredFunc {
	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "updated_at",
			Op:  comparison.IsNull,
		})
	}
}

func UpdatedAtIsNotNull() PredFunc {
	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "updated_at",
			Op:  comparison.IsNotNull,
		})
	}
}

func UpdatedAtIn(updatedAts ...*time.Time) PredFunc {
	args := []interface{}{}
	for _, v := range updatedAts {
		args = append(args, v)
	}

	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "updated_at",
			Op:  comparison.In,
			Arg: args,
		})
	}
}

func UpdatedAtNotIn(updatedAts ...*time.Time) PredFunc {
	args := []interface{}{}
	for _, v := range updatedAts {
		args = append(args, v)
	}

	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "updated_at",
			Op:  comparison.NotIn,
			Arg: args,
		})
	}
}

func CreatedAtEq(createdAt *time.Time) PredFunc {
	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "created_at",
			Op:  comparison.Eq,
			Arg: createdAt,
		})
	}
}

func CreatedAtNotEq(createdAt *time.Time) PredFunc {
	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "created_at",
			Op:  comparison.NotEq,
			Arg: createdAt,
		})
	}
}

func CreatedAtGt(createdAt *time.Time) PredFunc {
	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "created_at",
			Op:  comparison.Gt,
			Arg: createdAt,
		})
	}
}

func CreatedAtGtOrEq(createdAt *time.Time) PredFunc {
	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "created_at",
			Op:  comparison.GtOrEq,
			Arg: createdAt,
		})
	}
}

func CreatedAtLt(createdAt *time.Time) PredFunc {
	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "created_at",
			Op:  comparison.Lt,
			Arg: createdAt,
		})
	}
}

func CreatedAtLtOrEq(createdAt *time.Time) PredFunc {
	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "created_at",
			Op:  comparison.LtOrEq,
			Arg: createdAt,
		})
	}
}

func CreatedAtIsNull() PredFunc {
	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "created_at",
			Op:  comparison.IsNull,
		})
	}
}

func CreatedAtIsNotNull() PredFunc {
	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "created_at",
			Op:  comparison.IsNotNull,
		})
	}
}

func CreatedAtIn(createdAts ...*time.Time) PredFunc {
	args := []interface{}{}
	for _, v := range createdAts {
		args = append(args, v)
	}

	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "created_at",
			Op:  comparison.In,
			Arg: args,
		})
	}
}

func CreatedAtNotIn(createdAts ...*time.Time) PredFunc {
	args := []interface{}{}
	for _, v := range createdAts {
		args = append(args, v)
	}

	return func(pb *comparison.Predicates) {
		pb.Add(&comparison.Predicate{
			Col: "created_at",
			Op:  comparison.NotIn,
			Arg: args,
		})
	}
}
