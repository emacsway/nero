package gen

import (
	"os"
	"path"
	"strings"

	"github.com/dave/jennifer/jen"
	"github.com/iancoleman/strcase"
	"github.com/pkg/errors"

	"github.com/sf9v/nero"
	gen "github.com/sf9v/nero/gen/internal"
)

const (
	pkgPath = "github.com/sf9v/nero"
	header  = "Code generated by nero, DO NOT EDIT."
)

type file struct {
	path string
	f    *jen.File
}

func Generate(schemaer nero.Schemaer, genPath string) error {
	ns := schemaer.Schema()
	schema := &gen.Schema{
		Typ:  gen.NewTyp(schemaer),
		Cols: []*gen.Col{},
		Pkg:  ns.Pkg,
	}

	identCnt := 0
	for _, co := range ns.Columns {
		col := &gen.Col{
			Name:      co.Name,
			FieldName: toCamel(co.Name),
			Typ:       gen.NewTyp(co.T),
			Ident:     co.IsIdent,
			Auto:      co.IsAuto,
		}

		if len(co.FieldName) > 0 {
			col.FieldName = co.FieldName
		}

		if co.IsIdent {
			schema.Ident = col
			identCnt++
		}

		schema.Cols = append(schema.Cols, col)
	}

	if identCnt == 0 {
		return errors.New("at least one ident column is required")
	}

	if identCnt > 1 {
		return errors.New("only one ident column is allowed")
	}

	pkgName := strings.ToLower(schema.Pkg)
	pkgFile := jen.NewFile(pkgName)
	pkgFile.Const().Defs(
		jen.Id("collection").Op("=").Lit(ns.Collection),
	)

	files := []*file{{
		path: "meta.go",
		f:    pkgFile,
	}}

	predsFile := jen.NewFile(pkgName)
	predsFile.Add(newPredicates(schema))
	files = append(files, &file{
		path: "predicates.go",
		f:    predsFile,
	})

	repoFile := jen.NewFile(pkgName)
	repoFile.Add(newRepository(schema))
	files = append(files, &file{
		path: "repository.go",
		f:    repoFile,
	})

	creatorFile := jen.NewFile(pkgName)
	creatorFile.Add(newCreator(schema))
	files = append(files, &file{
		path: "creator.go",
		f:    creatorFile,
	})

	queryerFile := jen.NewFile(pkgName)
	queryerFile.Add(newQueryer(schema))
	files = append(files, &file{
		path: "queryer.go",
		f:    queryerFile,
	})

	updaterFile := jen.NewFile(pkgName)
	updaterFile.Add(newUpdater(schema))
	files = append(files, &file{
		path: "updater.go",
		f:    updaterFile,
	})

	deleterFile := jen.NewFile(pkgName)
	deleterFile.Add(newDeleter())
	files = append(files, &file{
		path: "deleter.go",
		f:    deleterFile,
	})

	// sqlite repository implementation
	sqliteRepoFile := jen.NewFile(pkgName)
	sqliteRepoFile.Anon("github.com/mattn/go-sqlite3")
	sqliteRepoFile.Add(newSQLiteRepo(schema))
	files = append(files, &file{
		path: "sqlite_repository.go",
		f:    sqliteRepoFile,
	})

	basePath := path.Join(genPath)
	err := os.MkdirAll(basePath, os.ModePerm)
	if err != nil {
		return errors.Wrap(err, "create base directory")
	}

	for _, file := range files {
		filePath := path.Join(basePath, file.path)
		f, err := os.Create(filePath)
		if err != nil {
			return errors.Wrapf(err, "create file: %s", filePath)
		}

		file.f.PackageComment(header)

		err = file.f.Render(f)
		if err != nil {
			return errors.Wrap(err, "render file")
		}
	}

	return nil
}

func toCamel(s string) string {
	return strcase.ToCamel(s)
}
