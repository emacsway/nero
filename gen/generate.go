package gen

import (
	"bytes"
	"strings"

	"github.com/dave/jennifer/jen"
	"github.com/iancoleman/strcase"
	"github.com/pkg/errors"

	"github.com/sf9v/nero"
	gen "github.com/sf9v/nero/gen/internal"
	"github.com/sf9v/nero/gen/postgres"
	"github.com/sf9v/nero/gen/sqlite"
)

const (
	pkgPath = "github.com/sf9v/nero"
	sqPkg   = "github.com/Masterminds/squirrel"
	errPkg  = "github.com/pkg/errors"
	header  = "Code generated by nero, DO NOT EDIT."
)

// Generate generates the repository and returns the output files
func Generate(schemaer nero.Schemaer) (Files, error) {
	schema, err := gen.BuildSchema(schemaer)
	if err != nil {
		return nil, err
	}

	pkgName := strings.ToLower(schema.Pkg)
	metaFile := jen.NewFile(pkgName)
	metaFile.Add(newMeta(schema))
	fls := []*File{{name: "meta.go", jf: metaFile}}

	predsFile := jen.NewFile(pkgName)
	predsFile.Add(newPredicates(schema))
	fls = append(fls, &File{
		name: "predicates.go",
		jf:   predsFile,
	})

	sortsFile := jen.NewFile(pkgName)
	sortsFile.Add(newSorts())
	fls = append(fls, &File{
		name: "sorts.go",
		jf:   sortsFile,
	})

	aggsFile := jen.NewFile(pkgName)
	aggsFile.Add(newAggregates())
	fls = append(fls, &File{
		name: "aggregates.go",
		jf:   aggsFile,
	})

	repoFile := jen.NewFile(pkgName)
	repoFile.Add(newRepository(schema))
	fls = append(fls, &File{
		name: "repository.go",
		jf:   repoFile,
	})

	aggtrFile := jen.NewFile(pkgName)
	aggtrFile.Add(newAggregator(schema))
	fls = append(fls, &File{
		name: "aggregator.go",
		jf:   aggtrFile,
	})

	creatorFile := jen.NewFile(pkgName)
	creatorFile.Add(newCreator(schema))
	fls = append(fls, &File{
		name: "creator.go",
		jf:   creatorFile,
	})

	queryerFile := jen.NewFile(pkgName)
	queryerFile.Add(newQueryer(schema))
	fls = append(fls, &File{
		name: "queryer.go",
		jf:   queryerFile,
	})

	updaterFile := jen.NewFile(pkgName)
	updaterFile.Add(newUpdater(schema))
	fls = append(fls, &File{
		name: "updater.go",
		jf:   updaterFile,
	})

	deleterFile := jen.NewFile(pkgName)
	deleterFile.Add(newDeleter())
	fls = append(fls, &File{
		name: "deleter.go",
		jf:   deleterFile,
	})

	// sqlite repository implementation
	sqliteFile := jen.NewFile(pkgName)
	sqliteFile.Anon("github.com/mattn/go-sqlite3")
	sqliteFile.Add(sqlite.NewSQLiteRepo(schema))
	fls = append(fls, &File{
		name: "sqlite.go",
		jf:   sqliteFile,
	})

	// postgres repository implementation
	postgresFile := jen.NewFile(pkgName)
	postgresFile.Anon("github.com/lib/pq")
	postgresFile.Add(postgres.NewPostgreSQLRepo(schema))
	fls = append(fls, &File{
		name: "postgres.go",
		jf:   postgresFile,
	})

	txFile := jen.NewFile(pkgName)
	txFile.Add(newTx())
	fls = append(fls, &File{
		name: "tx.go",
		jf:   txFile,
	})

	for i, fl := range fls {
		fl.jf.PackageComment(header)
		fl.jf.ImportAlias(sqPkg, "sq")

		buff := &bytes.Buffer{}
		err = fl.jf.Render(buff)
		if err != nil {
			return nil, errors.Wrap(err, "render jen file")
		}

		fls[i].buff = buff
	}

	return fls, nil
}

func camel(s string) string {
	return strcase.ToCamel(s)
}

func lowCamel(s string) string {
	return strcase.ToLowerCamel(s)
}
